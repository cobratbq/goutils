// SPDX-License-Identifier: LGPL-3.0-only

package compactsize

import (
	"testing"

	assert "github.com/cobratbq/goutils/std/testing"
)

func TestDecodeUint8(t *testing.T) {
	testdata := []struct {
		input []byte
		value uint8
		n     uint
	}{
		{[]byte{}, 0, 0},
		{[]byte{1}, 1, 1},
		{[]byte{0}, 0, 1},
		{[]byte{0xfc}, 0xfc, 1},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0, 0}, 0, 3},
		{[]byte{0xfd, 0xff, 0}, 0xff, 3},
		{[]byte{0xfd, 0xff, 1}, 0, 0},
		{[]byte{0xfd, 0xff, 0xff}, 0, 0},
		{[]byte{0xfd, 0xfe, 0}, 0xfe, 3},
		{[]byte{0xfe}, 0, 0},
		{[]byte{0xfe, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff}, 0, 0},
		{[]byte{0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
	}
	for _, test := range testdata {
		value, n := DecodeUint8(test.input)
		assert.Equal(t, test.n, n)
		assert.Equal(t, test.value, value)
	}
}

func TestDecodeUint16(t *testing.T) {
	testdata := []struct {
		input []byte
		value uint16
		n     uint
	}{
		{[]byte{}, 0, 0},
		{[]byte{1}, 1, 1},
		{[]byte{0}, 0, 1},
		{[]byte{0xee}, 0xee, 1},
		{[]byte{0xfc}, 0xfc, 1},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0, 0}, 0, 3},
		{[]byte{0xfd, 0xff, 0}, 0xff, 3},
		{[]byte{0xfd, 0xff, 1}, 0x01ff, 3},
		{[]byte{0xfd, 0xfe, 0}, 0xfe, 3},
		{[]byte{0xfd, 0, 0xff}, 0xff00, 3},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0xff}, 0, 0},
		{[]byte{0xfd, 0xff, 0xff}, 0xffff, 3},
		{[]byte{0xfe}, 0, 0},
		{[]byte{0xfe, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff}, 0, 0},
		{[]byte{0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
	}
	for _, test := range testdata {
		value, n := DecodeUint16(test.input)
		assert.Equal(t, test.n, n)
		assert.Equal(t, test.value, value)
	}
}

func TestDecodeUint32(t *testing.T) {
	testdata := []struct {
		input []byte
		value uint32
		n     uint
	}{
		{[]byte{}, 0, 0},
		{[]byte{1}, 1, 1},
		{[]byte{0}, 0, 1},
		{[]byte{0xee}, 0xee, 1},
		{[]byte{0xfc}, 0xfc, 1},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0, 0}, 0, 3},
		{[]byte{0xfd, 0xff, 0}, 0xff, 3},
		{[]byte{0xfd, 0xff, 1}, 0x01ff, 3},
		{[]byte{0xfd, 0xfe, 0}, 0xfe, 3},
		{[]byte{0xfd, 0, 0xff}, 0xff00, 3},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0xff}, 0, 0},
		{[]byte{0xfd, 0xff, 0xff}, 0xffff, 3},
		{[]byte{0xfe}, 0, 0},
		{[]byte{0xfe, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff, 0xff}, 0xffffffff, 5},
		{[]byte{0xff}, 0, 0},
		{[]byte{0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
	}
	for _, test := range testdata {
		value, n := DecodeUint32(test.input)
		assert.Equal(t, test.n, n)
		assert.Equal(t, test.value, value)
	}
}

func TestDecodeUint64(t *testing.T) {
	testdata := []struct {
		input []byte
		value uint64
		n     uint
	}{
		{[]byte{}, 0, 0},
		{[]byte{1}, 1, 1},
		{[]byte{0}, 0, 1},
		{[]byte{0xee}, 0xee, 1},
		{[]byte{0xfc}, 0xfc, 1},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0, 0}, 0, 3},
		{[]byte{0xfd, 0xff, 0}, 0xff, 3},
		{[]byte{0xfd, 0xff, 1}, 0x01ff, 3},
		{[]byte{0xfd, 0xfe, 0}, 0xfe, 3},
		{[]byte{0xfd, 0xff, 0xff}, 0xffff, 3},
		{[]byte{0xfd, 0, 0xff}, 0xff00, 3},
		{[]byte{0xfd}, 0, 0},
		{[]byte{0xfd, 0xff}, 0, 0},
		{[]byte{0xfd, 0xff, 0xff}, 0xffff, 3},
		{[]byte{0xfe}, 0, 0},
		{[]byte{0xfe, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xfe, 0xff, 0xff, 0xff, 0xff}, 0xffffffff, 5},
		{[]byte{0xff}, 0, 0},
		{[]byte{0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, 0},
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0xffffffffffffffff, 9},
		{[]byte{0xff, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 9},
	}
	for _, test := range testdata {
		value, n := DecodeUint64(test.input)
		assert.Equal(t, test.n, n)
		assert.Equal(t, test.value, value)
	}
}
